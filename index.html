<script>
  /* ===================== 게임 로직 + 구글 시트 랭킹 ===================== */

  const ROWS = 10;
  const COLS = 17;
  const TOTAL_TIME_MS = 120000;

  // ★ 여기를 자신의 Apps Script 웹앱 URL로 변경 ★
  const API_URL = "https://script.google.com/macros/s/AKfycbxUYwBX5y52suUKjl4Sk3YpA1Nopko5lMo-HQZkCgUSmh1uQ4g655J55WQUG6JW4xX7/exec";

  let board = [];
  let cellElements = [];

  let score = 0;
  let currentSum = 0;

  let dragging = false;
  let dragStartCell = null;
  let dragCurrentCell = null;

  let gameActive = false;
  let timeRemaining = TOTAL_TIME_MS;
  let timerInterval = null;

  // 서버에서 받아온 하이스코어 리스트
  let highScores = []; // {name, score, timestamp}

  const menuScreen = document.getElementById("menuScreen");
  const gameScreen = document.getElementById("gameScreen");
  const endOverlay = document.getElementById("endOverlay");

  const playBtn = document.getElementById("playBtn");
  const menuResetBtn = document.getElementById("menuResetBtn");

  const gameBoardEl = document.getElementById("gameBoard");
  const selectionRectEl = document.getElementById("selectionRect");

  const scoreLabel = document.getElementById("scoreLabel");
  const sumLabel = document.getElementById("sumLabel");
  const timeLabel = document.getElementById("timeLabel");
  const timeBar = document.getElementById("timeBar");

  const finalScoreText = document.getElementById("finalScoreText");

  const resetGameBtn = document.getElementById("resetGameBtn");
  const backMenuBtn = document.getElementById("backMenuBtn");
  const retryBtn = document.getElementById("retryBtn");
  const endMenuBtn = document.getElementById("endMenuBtn");

  const highScoreListEl = document.getElementById("highScoreList");
  const highScoreFormEl = document.getElementById("highScoreForm");
  const highScoreNameInputEl = document.getElementById("highScoreNameInput");
  const saveHighScoreBtn = document.getElementById("saveHighScoreBtn");

  /* ---------- 화면 전환 ---------- */

  function showMenu() {
    menuScreen.classList.remove("hidden");
    gameScreen.classList.add("hidden");
    hideEndOverlay();
    stopTimer();
  }

  function showGame() {
    menuScreen.classList.add("hidden");
    gameScreen.classList.remove("hidden");
    hideEndOverlay();
  }

  function showEndOverlay() {
    endOverlay.classList.remove("hidden");
  }

  function hideEndOverlay() {
    endOverlay.classList.add("hidden");
    hideHighScoreForm();
  }

  /* ---------- 보드 ---------- */

  function initBoard() {
    board = [];
    for (let r = 0; r < ROWS; r++) {
      const row = [];
      for (let c = 0; c < COLS; c++) {
        row.push(Math.floor(Math.random() * 9) + 1);
      }
      board.push(row);
    }
  }

  function renderBoard() {
    const oldRect = selectionRectEl;
    gameBoardEl.innerHTML = "";
    gameBoardEl.appendChild(oldRect);

    cellElements = Array.from({ length: ROWS }, () => Array(COLS));

    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const v = board[r][c];
        const cell = document.createElement("div");
        cell.classList.add("cell");
        cell.dataset.row = r;
        cell.dataset.col = c;

        if (v === 0) {
          cell.classList.add("empty");
        } else {
          const orange = document.createElement("div");
          orange.classList.add("orange");
          const numEl = document.createElement("div");
          numEl.classList.add("orange-number");
          numEl.textContent = v;
          orange.appendChild(numEl);
          cell.appendChild(orange);
        }

        cellElements[r][c] = cell;
        gameBoardEl.appendChild(cell);
      }
    }
  }

  function updateScoreUI() {
    scoreLabel.textContent = score;
    sumLabel.textContent = currentSum;
  }

  /* ---------- 타이머 ---------- */

  function startTimer() {
    if (timerInterval) clearInterval(timerInterval);

    timerInterval = setInterval(() => {
      if (!gameActive) return;

      timeRemaining -= 100;
      if (timeRemaining <= 0) {
        timeRemaining = 0;
        endGame();
      }
      updateTimerUI();
    }, 100);
  }

  function stopTimer() {
    if (timerInterval) {
      clearInterval(timerInterval);
      timerInterval = null;
    }
  }

  function updateTimerUI() {
    timeLabel.textContent = (timeRemaining / 1000).toFixed(1) + "초";
    timeBar.style.transform = `scaleX(${timeRemaining / TOTAL_TIME_MS})`;
  }

  /* ---------- 게임 시작/종료 ---------- */

  function startGame() {
    hideEndOverlay();
    stopTimer();

    initBoard();
    renderBoard();

    score = 0;
    currentSum = 0;
    timeRemaining = TOTAL_TIME_MS;
    gameActive = true;

    updateScoreUI();
    updateTimerUI();
    startTimer();
  }

  function endGame() {
    gameActive = false;
    stopTimer();
    finalScoreText.textContent = score + "점";

    // 서버 랭킹 기준으로 새 기록인지 체크
    if (isNewHighScore(score)) {
      showHighScoreForm();
    } else {
      hideHighScoreForm();
    }

    showEndOverlay();
  }

  /* ---------- 드래그 선택 ---------- */

  function getCellFromEvent(e) {
    const t = e.target.closest(".cell");
    if (!t) return null;
    return {
      r: parseInt(t.dataset.row),
      c: parseInt(t.dataset.col)
    };
  }

  function getSelectedCells() {
    if (!dragStartCell || !dragCurrentCell) return [];

    const r1 = Math.min(dragStartCell.r, dragCurrentCell.r);
    const r2 = Math.max(dragStartCell.r, dragCurrentCell.r);
    const c1 = Math.min(dragStartCell.c, dragCurrentCell.c);
    const c2 = Math.max(dragStartCell.c, dragCurrentCell.c);

    const arr = [];
    for (let r = r1; r <= r2; r++) {
      for (let c = c1; c <= c2; c++) {
        if (board[r][c] !== 0) arr.push({ r, c });
      }
    }
    return arr;
  }

  function updateSelection() {
    const cells = getSelectedCells();
    currentSum = cells.reduce((a, { r, c }) => a + board[r][c], 0);

    updateScoreUI();

    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        cellElements[r][c].classList.remove("selected");
      }
    }

    cells.forEach(({ r, c }) => {
      cellElements[r][c].classList.add("selected");
    });

    if (!dragStartCell || !dragCurrentCell) {
      selectionRectEl.style.display = "none";
      return;
    }

    const sEl = cellElements[dragStartCell.r][dragStartCell.c];
    const eEl = cellElements[dragCurrentCell.r][dragCurrentCell.c];

    const boardRect = gameBoardEl.getBoundingClientRect();
    const sRect = sEl.getBoundingClientRect();
    const eRect = eEl.getBoundingClientRect();

    const left = Math.min(sRect.left, eRect.left) - boardRect.left;
    const top = Math.min(sRect.top, eRect.top) - boardRect.top;
    const right = Math.max(sRect.right, eRect.right) - boardRect.left;
    const bottom = Math.max(sRect.bottom, eRect.bottom) - boardRect.top;

    selectionRectEl.style.display = "block";
    selectionRectEl.style.left = left + "px";
    selectionRectEl.style.top = top + "px";
    selectionRectEl.style.width = (right - left) + "px";
    selectionRectEl.style.height = (bottom - top) + "px";

    gameBoardEl.classList.remove("valid", "over10");
    if (currentSum === 10) gameBoardEl.classList.add("valid");
    else if (currentSum > 10) gameBoardEl.classList.add("over10");
  }

  function clearSelection() {
    dragStartCell = null;
    dragCurrentCell = null;
    currentSum = 0;
    updateScoreUI();
    selectionRectEl.style.display = "none";

    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        cellElements[r][c].classList.remove("selected");
      }
    }

    gameBoardEl.classList.remove("valid", "over10");
  }

  function onPointerDown(e) {
    if (!gameActive) return;
    const cell = getCellFromEvent(e);
    if (!cell || board[cell.r][cell.c] === 0) return;

    dragging = true;
    dragStartCell = cell;
    dragCurrentCell = cell;
    updateSelection();
  }

  function onPointerMove(e) {
    if (!dragging || !gameActive) return;

    const cell = getCellFromEvent(e);
    if (!cell) return;

    if (dragCurrentCell.r === cell.r && dragCurrentCell.c === cell.c) return;

    dragCurrentCell = cell;
    updateSelection();
  }

  function onPointerUp() {
    if (!dragging) return;
    dragging = false;

    if (currentSum === 10) {
      const cells = getSelectedCells();
      cells.forEach(({ r, c }) => board[r][c] = 0);
      score += cells.length;
    }

    clearSelection();
    renderBoard();
  }

  /* ---------- 구글 시트 랭킹 연동 ---------- */

  // 서버에서 랭킹 가져오기
  async function fetchHighScores() {
    try {
      const res = await fetch(API_URL);
      const data = await res.json();
      if (data.status === 'ok' && Array.isArray(data.records)) {
        highScores = data.records;
      } else {
        highScores = [];
      }
    } catch (e) {
      console.error('fetchHighScores error', e);
      highScores = [];
    }
    renderHighScores();
  }

  function renderHighScores() {
    highScoreListEl.innerHTML = "";

    if (!highScores.length) {
      const li = document.createElement("li");
      li.textContent = "아직 기록이 없습니다. 첫 기록의 주인공이 되어보세요!";
      highScoreListEl.appendChild(li);
      return;
    }

    // TOP 5만 메뉴에 보여주기
    highScores.slice(0, 5).forEach((rec) => {
      const li = document.createElement("li");
      const name = rec.name || "무명";
      li.textContent = `${name} – ${rec.score}점`;
      highScoreListEl.appendChild(li);
    });
  }

  function isNewHighScore(newScore) {
    if (newScore <= 0) return false;
    if (!highScores.length) return true;
    const sorted = [...highScores].sort((a, b) => b.score - a.score);
    if (sorted.length < 5) return true;
    const minScore = sorted[sorted.length - 1].score;
    return newScore > minScore;
  }

  function showHighScoreForm() {
    highScoreFormEl.classList.remove("hidden");
    highScoreNameInputEl.value = "";
    highScoreNameInputEl.focus();
  }

  function hideHighScoreForm() {
    highScoreFormEl.classList.add("hidden");
  }

  async function saveCurrentScoreToHighScores() {
    const name = highScoreNameInputEl.value.trim() || "무명";

    try {
      await fetch(API_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name, score })
      });
    } catch (e) {
      console.error("saveCurrentScore error", e);
    }

    await fetchHighScores(); // 다시 받아와서 화면 갱신
    hideHighScoreForm();
  }

  /* ---------- 이벤트 바인딩 ---------- */

  playBtn.onclick = () => {
    showGame();
    startGame();
  };
  menuResetBtn.onclick = () => {
    showGame();
    startGame();
  };

  resetGameBtn.onclick = startGame;
  backMenuBtn.onclick = showMenu;
  retryBtn.onclick = () => {
    hideEndOverlay();
    startGame();
  };
  endMenuBtn.onclick = showMenu;

  saveHighScoreBtn.onclick = () => {
    saveCurrentScoreToHighScores();
  };

  gameBoardEl.addEventListener("pointerdown", onPointerDown);
  gameBoardEl.addEventListener("pointermove", onPointerMove);
  window.addEventListener("pointerup", onPointerUp);

  // 초기 로딩
  window.addEventListener("load", () => {
    fetchHighScores(); // 서버에서 랭킹 불러오기
    showMenu();
  });
</script>
